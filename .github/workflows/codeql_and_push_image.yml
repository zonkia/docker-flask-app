name: Release Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  TF_CLOUD_ORGANIZATION: "stanle1-home"
  TF_API_TOKEN: "${{ secrets.TF_API_TOKEN }}"
  TF_WORKSPACE: "docker-flask-app"
  CONFIG_DIRECTORY: "./"
  APP_PORT: "80"

jobs:
  # analyze:
  #   name: Analyze code
  #   runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
  #   timeout-minutes: ${{ (matrix.language == 'swift' && 120) || 360 }}
  #   permissions:
  #     actions: read
  #     contents: read
  #     security-events: write
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       language: [ 'python' ]

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v3

  #   - name: Initialize CodeQL
  #     uses: github/codeql-action/init@v2
  #     with:
  #       languages: ${{ matrix.language }}

  #   - name: Autobuild
  #     uses: github/codeql-action/autobuild@v2

  #   - name: Perform CodeQL Analysis
  #     uses: github/codeql-action/analyze@v2
  #     with:
  #       category: "/language:${{matrix.language}}"

  tag_repo:
    if: github.event_name == 'push'
    #needs: analyze
    runs-on: ubuntu-22.04
    name: Tag Repository
    permissions:
      contents: write
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: '0'

    - name: Bump version and push tag
      id: bump
      uses: anothrNick/github-tag-action@1.64.0 # Don't use @master or @v1 unless you're happy to test the latest version
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # if you don't want to set write permissions use a PAT token
        WITH_V: true
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}

  build:
    if: github.event_name == 'push'
    needs: tag_repo
    name: Build Image and Push to ECR
    runs-on: ubuntu-latest
    steps:

    - name: Check out code
      uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-central-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1.6.2

    - name: Build, tag, and push image to Amazon ECR
      id: build
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: docker-flask-app
        IMAGE_TAG: ${{ needs.tag_repo.outputs.new_tag }}
        SECRET: ${{ secrets.SECRET_SIGNING_PASSPHRASE }}
      run: |
        cd image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
  release:
    runs-on: ubuntu-latest
    needs: [build, tag_repo]
    name: Release || Rollback
    steps:

    - name: Release
      id: create_release
      if: needs.tag_repo.outputs.new_tag != ''
      uses: actions/create-release@v1.1.4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.tag_repo.outputs.new_tag }}
        release_name: Version ${{ needs.tag_repo.outputs.new_tag }}
        draft: false
        #prerelease: true

    - name: Rollback Release
      if: failure() && steps.create_release.outputs.id != ''
      uses: author/action-rollback@1.0.3
      with:
        id: ${{ steps.create_release.id }}
        tag: ${{ needs.tag_repo.outputs.new_tag }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  terraform:
    needs: [release, build, tag_repo]
    runs-on: ubuntu-latest
    name: "Terraform Apply"
    env:
      SECRET: ${{ secrets.SECRET_SIGNING_PASSPHRASE }}
    steps:
    - name: Clone the repository code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: eu-central-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1.6.2

    - name: Setup the Terraform CLI
      uses: hashicorp/setup-terraform@v1
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
        terraform_wrapper: false

    - name: Initialize the Terraform working directory
      working-directory: ./
      id: init
      run: terraform init

    - name: Setup Terraform variables
      working-directory: ./
      id: vars
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: docker-flask-app
        IMAGE_TAG: ${{ needs.tag_repo.outputs.new_tag }}
      run: |
        cat > terraform.tfvars <<EOF
        image_name = "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        ecr_registry = "$ECR_REGISTRY/$ECR_REPOSITORY"
        app_port = "$APP_PORT"
        EOF

    - name: Apply the Terraform execution plan
      working-directory: ./
      id: apply
      run: |
        terraform apply -target=local_file.terra-ssh-key -auto-approve -no-color 
        chmod 600 myKey.pem
        cat myKey.pem
        echo "::set-output name=SSH_KEY::$(cat myKey.pem)"
        echo "::set-output name=EIP::$(terraform output eip_address)"

    - name: Check the application with Rollback
      working-directory: ./
      id: check
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: docker-flask-app
        KEY: "${{ steps.apply.outputs.SSH_KEY }}"
        APP_ADDRESS: ${{ steps.apply.outputs.EIP }}
      run: |
        export ip=$(echo "${APP_ADDRESS//\"}")
        export current_ip=$(curl https://api.ipify.org)
        export sg_id=$(aws ec2 describe-security-groups --query "SecurityGroups[?GroupName == 'terra-front-sg'].GroupId[]" --output text)
        export sg_rule=$(aws ec2 describe-security-group-rules --query 'SecurityGroupRules[?GroupId==`'$sg_id'`&&FromPort==`22`].SecurityGroupRuleId' --output text)
        aws ec2 modify-security-group-rules --group-id $sg_id --security-group-rules SecurityGroupRuleId=$sg_rule,SecurityGroupRule='{IpProtocol=tcp,FromPort=22,ToPort=22,CidrIpv4='$current_ip'/32}'

        export container_status="$(ssh -i myKey.pem -o StrictHostKeyChecking=no "ec2-user@$ip" sudo docker container inspect -f '{{.State.Running}}' flask_app)"
        export app_status=$(curl -LI http://$ip/ -o /dev/null -w '%{http_code}\n' -s)
        echo $container_status
        echo $app_status

        export previous_version=$(aws ecr describe-images --repository-name docker-flask-app --query 'sort_by(imageDetails,& imagePushedAt)[-2].imageTags[0]' --output text)
        echo $previous_version
        echo $ECR_REGISTRY/$ECR_REPOSITORY:$previous_version
        echo $APP_PORT

        if [ "200" = "$app_status" ]
        then
        echo dwiescie
        fi

        if [ " true" = "$container_status" ]
        then
        echo container2
        fi

        if [ "true" = "$container_status" ]
        then
        echo container2
        fi

        if [[ "200" = "$app_status" && "true" = "$container_status" ]]
        then
        echo ok
        else
        echo NOT
        fi


    # sleep 1m
    # container_status=$(ssh -i myKey.pem -o StrictHostKeyChecking=no "ec2-user@$ip" sudo docker container inspect -f '{{.State.Running}}' flask_app)
    # app_status=$(curl -LI http://$ip/ -o /dev/null -w '%{http_code}\n' -s)
    # if [[ "200" = "$app_status" && "true" = "container_status" ]]
    # then
    # echo ok
    # else
    # img_ver=$(aws ecr describe-images --repository-name docker-flask-app --query 'sort_by(imageDetails,& imagePushedAt)[-2].imageTags[0]' --output text)
    # ssh -i myKey.pem -o StrictHostKeyChecking=no "ec2-user@$ip" sudo docker run -it -e PORT=$APP_PORT -p $APP_PORT:$APP_PORT -d $ECR_REGISTRY/$ECR_REPOSITORY:$previous_version
    # fi

    # - name: Rollback to previous version if apply failed
    #   if: failure()
    #   working-directory: ./
    #   env:
    #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
    #     ECR_REPOSITORY: docker-flask-app
    #   run: |
    #     img_ver=$(aws ecr describe-images --repository-name docker-flask-app --query 'sort_by(imageDetails,& imagePushedAt)[-2].imageTags[0]' --output text)
    #     cat > terraform.tfvars <<EOF
    #     image_name = "$ECR_REGISTRY/$ECR_REPOSITORY:$img_ver"
    #     ecr_registry = "$ECR_REGISTRY/$ECR_REPOSITORY"
    #     EOF
    #     terraform apply -auto-approve -no-color

    # - name: Rollback to previous version if apply failed
    #   if: failure()
    #   env:
    #       PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
    #       HOSTNAME: ${{secrets.SSH_HOST}}
    #       USER_NAME: ${{secrets.USER_NAME}}
    
    #   run: |
    #     echo "$PRIVATE_KEY" > private_key && chmod 600 private_key
    #     ssh -o StrictHostKeyChecking=no -i private_key ${USER_NAME}@${HOSTNAME} '

    #         # Now we have got the access of EC2 and we will start the deploy .
    #         cd /home/ubuntu/<PROJECT_DIRECTORY> &&
    #         git checkout dev &&
    #         git fetch --all &&
    #         git reset --hard origin/dev &&
    #         git pull origin dev &&
    #         sudo npm i &&
    #         sudo npm run build &&
    #         sudo pm2 stop ./dist/index.js &&
    #         sudo pm2 start ./dist/index.js
    #         '